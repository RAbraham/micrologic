<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>microLogic</title>
<!-- 2014-12-30 Tue 10:36 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Russell Mull" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-light.min.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">microLogic</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a></li>
<li><a href="#sec-2">2. Relational core</a>
<ul>
<li><a href="#sec-2-1">2.1. Logic Variables</a></li>
<li><a href="#sec-2-2">2.2. Substitutions and Walking</a></li>
<li><a href="#sec-2-3">2.3. Unification</a></li>
<li><a href="#sec-2-4">2.4. Lazy Streams</a>
<ul>
<li><a href="#sec-2-4-1">2.4.1. The definition of a logic program</a></li>
<li><a href="#sec-2-4-2">2.4.2. Definition of a lazy stream</a></li>
<li><a href="#sec-2-4-3">2.4.3. Empty stream</a></li>
<li><a href="#sec-2-4-4">2.4.4. Mature streams (StreamNode)</a></li>
<li><a href="#sec-2-4-5">2.4.5. Immature streams (IFn)</a></li>
<li><a href="#sec-2-4-6">2.4.6. Differences from Clojure's Seq</a></li>
</ul>
</li>
<li><a href="#sec-2-5">2.5. Goals</a>
<ul>
<li><a href="#sec-2-5-1">2.5.1. States</a></li>
<li><a href="#sec-2-5-2">2.5.2. Goal functions</a></li>
<li><a href="#sec-2-5-3">2.5.3. Basic goal constructors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. Sugar</a>
<ul>
<li><a href="#sec-3-1">3.1. Auxilliary macros</a></li>
<li><a href="#sec-3-2">3.2. Reificiation</a></li>
<li><a href="#sec-3-3">3.3. Programmer interface</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Sequences</a>
<ul>
<li><a href="#sec-4-1">4.1. Extending the core</a></li>
<li><a href="#sec-4-2">4.2. Sequence relations</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Back matter</a>
<ul>
<li><a href="#sec-5-1">5.1. Bibliography</a></li>
<li><a href="#sec-5-2">5.2. Differences from microKanren</a></li>
<li><a href="#sec-5-3">5.3. Differences from core.logic</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
This is a literate implementation of miniKanren, a logic programming
system.  It's meant to be an introduction to the inner workings of
miniKanren and and of core.logic.
</p>

<p>
For maximum enjoyment, the reader should be familiar with Clojure, and
in particular with protocols. In lieu of that, basic understanding of
lisp syntax and a read through something like
<a href="http://clojure-doc.org/articles/language/polymorphism.html">http://clojure-doc.org/articles/language/polymorphism.html</a> should be
sufficient.
</p>

<p>
This code was derived substantially from microKanren; for more
information, see the bibliography at the end.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Relational core</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Logic Variables</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The purpose of a logic program is to takes an expression with some
unknowns in it and try to find values for those unknowns. Here's an
example logic program in English with an unknown <i>x</i>:
</p>

<blockquote>
<p>
Either x is the beginning of the list ["banana", "orange", "apple"],
or x is the number 1.
</p>
</blockquote>

<p>
(The two values of <i>x</i> that make this expression succeed are <code>1</code> and <code>banana</code>)
</p>

<p>
These unknowns are called <i>logic variables</i>, or <i>lvars</i> for
short. Since we're going to write our logic programs in Clojure, we
need a way to represent them.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defrecord</span> <span style="color: #228b22;">LVar</span> [id])
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">lvar</span> [id] (<span style="color: #228b22;">LVar.</span> id))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">lvar?</span> [x] (instance? <span style="color: #228b22;">LVar</span> x))
</pre>
</div>

<p>
An lvar's <i>id</i> could be anything, but we use it like a serial
number. The first lvar gets created with id 0, the next with id 1, and
so on. There is some special syntax to help with that, which we'll see
below.
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Substitutions and Walking</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Once we have determined a value for an lvar, we put it into a
substitution map (<i>s-map</i> for short). This is a regular clojure
hash-map with an lvar as a key. For example,
</p>

<div class="org-src-container">

<pre class="src src-clojure">{ (lvar 0) <span style="color: #8b2252;">"banana"</span> }
</pre>
</div>

<p>
is a substitution map that makes the above example succeed (as long as
<i>x</i> is lvar 0).
</p>

<p>
There is one twist to the substitution map: lvars can be values, as
well.  (This is called a <i>triangular</i> substitution) Here is an example
whose solution is a triangular substitution:
</p>

<blockquote>
<p>
Either x is the beginning of the list [y, "orange", "apple"], or x
is the number 1.
</p>

<p>
y is the string "banana".
</p>
</blockquote>

<p>
One substitution map which will make this example succeed is
</p>
<div class="org-src-container">

<pre class="src src-clojure">{ (lvar 0) (lvar 1)
  (lvar 1) <span style="color: #8b2252;">"banana"</span> }
</pre>
</div>

<p>
We define two operations on the substitution map. The first is for
adding add new entries.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">add-substitution</span> [s-map lvar value]
  (<span style="color: #a020f0;">when</span> s-map
    (assoc s-map lvar value)))
</pre>
</div>

<p>
If you try to add something to a <code>nil</code> substitution map, we just
return <code>nil</code>. The <code>nil</code> substitution map is output when there are no
substitutions that can make an expression succeed. We'll see where
this is important when we start to build up substitution maps.
</p>

<p>
The other operation on a substitution map is to look things up. It's just
a hash-map, so why don't we just use the <code>get</code> function for this? Two reasons:
</p>

<ul class="org-ul">
<li>If there is an lvar on the right-hand side, we need to look up that
value, following them until we get to a non-lvar.
</li>

<li>The <code>walk</code> function really means "give me the value of object,
given this substitution map". So if you walk with a value that's
not an lvar, it should just give you that value back.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(extend-protocol <span style="color: #228b22;">IWalk</span>
  <span style="color: #228b22;">LVar</span>
  (walk [u s-map] (<span style="color: #a020f0;">if-let</span> [val (get s-map u)]
                    (<span style="color: #a020f0;">recur</span> val s-map)
                    u))
  <span style="color: #228b22;">Object</span>
  (walk [u s-map] u)

  <span style="color: #008b8b;">nil</span>
  (walk [u s-map] <span style="color: #008b8b;">nil</span>))
</pre>
</div>

<p>
Here are some example <code>walk</code> invocations:
</p>
<div class="org-src-container">

<pre class="src src-clojure">&gt; (<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">s-map</span> { (lvar 0) (lvar 1)
               (lvar 1) <span style="color: #8b2252;">"banana"</span> })

&gt; (walk (lvar 0) s-map)
<span style="color: #8b2252;">"banana"</span>

&gt; (walk (lvar 1) s-map)
<span style="color: #8b2252;">"banana"</span>

&gt; (walk <span style="color: #8b2252;">"mango"</span> s-map)
<span style="color: #8b2252;">"mango"</span>
</pre>
</div>


<p>
You might notice that it is easy to construct a substitution map with
a loop in it: <code>(walk a {a b, b a})</code> will not terminate. Most implementations
would handle that with a check in <code>add-substitution</code>, but we omit it here
for simplicity. (it's typically called <code>occurs-check</code>)
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Unification</h3>
<div class="outline-text-3" id="text-2-3">
<p>
<code>unify</code> is the way we build up substitution maps. Given two values <i>u</i>
and <i>v</i>, and an existing substitution map <i>s-map</i>, <code>unify</code> produces a
new substitution map with mappings that will make u and v equal.
</p>

<p>
This is a rather subtle; let's walk through some examples.
</p>

<ul class="org-ul">
<li>First, if either <i>u</i> or <i>v</i> is an lvar, the unifying them with a
value just like assigning a value.

<div class="org-src-container">

<pre class="src src-clojure">&gt; (unify (lvar 0) <span style="color: #8b2252;">"banana"</span> {})
{(lvar 0) <span style="color: #8b2252;">"banana"</span>}

&gt; (unify <span style="color: #8b2252;">"banana"</span> (lvar 0) {})
{(lvar 0) <span style="color: #8b2252;">"banana"</span>}
</pre>
</div>
</li>

<li>But what if the lvar already has a value? Then there are two
possibilities. Either the two values agree:
<div class="org-src-container">

<pre class="src src-clojure">&gt; (unify (lvar 0) <span style="color: #8b2252;">"banana"</span>
         {(lvar 0) <span style="color: #8b2252;">"banana"</span>})
{(lvar 0) <span style="color: #8b2252;">"banana"</span>}
</pre>
</div>

<p>
Or they do not, leading to a contradiction:
</p>
<div class="org-src-container">

<pre class="src src-clojure">&gt; (unify (lvar 0) <span style="color: #8b2252;">"banana"</span>
         {(lvar 0) <span style="color: #8b2252;">"mango"</span>})
<span style="color: #008b8b;">nil</span>
</pre>
</div>
</li>

<li>When there's something un-related in the substitution map,
we'll just add to it:
<div class="org-src-container">

<pre class="src src-clojure">&gt; (unify (lvar 0) <span style="color: #8b2252;">"banana"</span>
         {(lvar 9) <span style="color: #8b2252;">"squirrels"</span>})
{(lvar 0) <span style="color: #8b2252;">"banana"</span>
 (lvar 9) <span style="color: #8b2252;">"squirrels"</span>}
</pre>
</div>
</li>
</ul>

<p>
That's it for the basic cases. They seem pretty trivial, but our unifier has
one more nice feature: extensibility. By extending the IUnifyTerms protocol,
you can add unification behavior for other data structures as well. We do
this for sequences later on. But until then, here's a preview:
</p>

<div class="org-src-container">

<pre class="src src-clojure">&gt; (unify [(lvar 0) 2 3] [<span style="color: #8b2252;">"banana"</span> 2 3] {})
{(lvar 0) <span style="color: #8b2252;">"banana"</span>}
</pre>
</div>

<p>
Here's the implementation of <code>unify</code>:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">unify</span> [u v s-map]
  (<span style="color: #a020f0;">let</span> [u (walk u s-map),    v (walk v s-map)
        u-is-lvar (lvar? u), v-is-lvar (lvar? v)]
    (<span style="color: #a020f0;">cond</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">TODO is this case right???</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">Unifying two lvars adds no information to the substitution map</span>
      (<span style="color: #a020f0;">and</span> u-is-lvar v-is-lvar (= u v)) s-map

      <span style="color: #b22222;">;; </span><span style="color: #b22222;">Unifying an lvar with some other value creates a new entry in</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">the substitution map</span>
      u-is-lvar (add-substitution s-map u v)
      v-is-lvar (add-substitution s-map v u)

      <span style="color: #b22222;">;; </span><span style="color: #b22222;">two non-lvar values unify if they're equal</span>
      (= u v) s-map

      <span style="color: #b22222;">;; </span><span style="color: #b22222;">Unifying two non-lvars is delegated to the polymorphic</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">unify-terms function, from IUnifyTerms.</span>
      <span style="color: #008b8b;">:default</span> (unify-terms u v s-map))))
</pre>
</div>

<p>
Here are the basic IUnifyTerms definitions for Object and nil.  If we
get dispatched to either of these definitions, we know that neither u
or v is an lvar, that they aren't equal, and we aren't doing some kind
of structural comparison defined elsewhere. They must not unify.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(extend-protocol <span style="color: #228b22;">IUnifyTerms</span>
  <span style="color: #228b22;">Object</span> (unify-terms [u v s-map] <span style="color: #008b8b;">nil</span>)
  <span style="color: #008b8b;">nil</span>    (unify-terms [u v s-map] <span style="color: #008b8b;">nil</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Lazy Streams</h3>
<div class="outline-text-3" id="text-2-4">
<p>
As we've alluded to above, when you run a logic program you can get more than
one result. MiniKanren's approach to this is really unique, and is one
of the most interesting parts of the program.
</p>

<p>
First, let's make a case for why we need a lazy stream
mechanism. Consider the program:
</p>
<blockquote>
<p>
Define Natural(x) to be true when either:
</p>
<ul class="org-ul">
<li>x is the number 0
</li>
<li>x is greater than 0, and Natural(x - 1) is true
</li>
</ul>
</blockquote>

<p>
Clearly there are an infinite number of substitution maps that make
this program succeed - <code>{(lvar 0) 0}</code>, <code>{(lvar 0) 1}</code>, <code>{(lvar 0) 2}</code>,
and so on.
</p>
</div>

<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> The definition of a logic program</h4>
<div class="outline-text-4" id="text-2-4-1">
<ol class="org-ol">
<li>In miniKanren, <i>the output of a logic program is a set of
substitutions</i> that make that program succeed.
</li>

<li>A logic program is built by combining smaller logic programs using
the conjunction (and) and disjunction (or) operators.
</li>
</ol>

<p>
But we just saw that some logic programs may have an infinitely large
set of solutions. Clearly, we'll need to impose some order oin
them. And if you're combining two programs, each with infinite output,
there must be some way of going back and forth between the output of
each. This is the motivation for lazy streams.
</p>
</div>
</div>

<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> Definition of a lazy stream</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
There are three kinds of lazy streams:
</p>
<ul class="org-ul">
<li>Empty
</li>
<li>Mature (head realized)
</li>
<li>Immature (head unrealized)
</li>
</ul>

<p>
A mature stream is one in which the first element of the stream has a
definite value that has already been computed. An immature stream, on
the other hand, does not yet have a computed head. Instead if has a
function which it can used to compute a mature (or empty) stream when
you need it.
</p>

<p>
You can manipulate a stream with these functions:
</p>
<ul class="org-ul">
<li>Merge two of them together with <code>merge-streams</code>
</li>
<li>Map a function over it with <code>mapcat-stream</code>, as long as that
function itself produces streams.
</li>
<li>Realize its head with <code>realize-stream-head</code>. This will transition it
to either immature or empty, performing any necessary work along the
way.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3"><span class="section-number-4">2.4.3</span> Empty stream</h4>
<div class="outline-text-4" id="text-2-4-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">empty-stream</span>
  (reify <span style="color: #228b22;">IStream</span>
    (merge-streams [stream-1 stream-2] stream-2)
    (mapcat-stream [stream g] stream)
    (realize-stream-head [stream] stream)
    (stream-to-seq [stream] '())))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-4" class="outline-4">
<h4 id="sec-2-4-4"><span class="section-number-4">2.4.4</span> Mature streams (StreamNode)</h4>
<div class="outline-text-4" id="text-2-4-4">
<p>
A mature streams is represented by an instance of StreamNode.  This is
kind of like a linked list: <i>head</i> is the realized value that can be
taken from the stream, and <i>next</i> is the stream which follows.  But
these streams are polymorphic; <i>next</i> isn't necessarily a StreamNode,
just some other thing which extends the IStream protocol.
</p>

<p>
Note that, if we have only StreamNodes (i.e. fully realized streams),
<code>merge-streams</code> is equivalent to <code>concat</code> and <code>mapcat-stream</code> to
<code>mapcat</code>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">  (<span style="color: #a020f0;">deftype</span> <span style="color: #228b22;">StreamNode</span> [head next]
    <span style="color: #228b22;">IStream</span>
    (merge-streams [stream-1 stream-2] (<span style="color: #228b22;">StreamNode.</span> head
                                                    (merge-streams next stream-2)))
    (mapcat-stream [stream g] (merge-streams (g head)
                                             (mapcat-stream next g)))
    (realize-stream-head [stream] stream)

    (stream-to-seq [stream] (lazy-seq (cons head (stream-to-seq next)))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">make-stream</span> [s] (<span style="color: #228b22;">StreamNode.</span> s empty-stream))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-5" class="outline-4">
<h4 id="sec-2-4-5"><span class="section-number-4">2.4.5</span> Immature streams (IFn)</h4>
<div class="outline-text-4" id="text-2-4-5">
<p>
An immature stream is represented by a thunk (a function of no
arguments).
</p>

<p>
Executing the thunk does one unit of work and returns a new
stream. This may in turn be a function, so you might have to keep
calling the returned function many times until you get down to a
realized value. This is exactly what <code>realize-stream-head</code> does here,
by way of <code>trampoline</code>.
</p>
</div>

<ol class="org-ol"><li><a id="sec-2-4-5-1" name="sec-2-4-5-1"></a>Merging<br  /><div class="outline-text-5" id="text-2-4-5-1">
<p>
Merging is tricky - this is what makes the search interleaving. Let's
examine the definition:
</p>
<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #228b22;">clojure.lang.IFn</span>
(merge-streams [stream-1 stream-2]
  #(merge-streams stream-2 (stream-1)))
</pre>
</div>


<p>
Working from the inside out: we know that stream-1 is a function because
we're extending IStream onto IFn; calling it will perform one 'step
of computation', whatever that might be. It returns a stream.
Then we merge that stream with stream-2, the second parameter of this merge operation,
<i>but the order is reversed</i>.
</p>

<p>
Finally, the above operation is all wrapped in a thunk. So we end up with a
function that:
</p>

<ul class="org-ul">
<li>performs the work for the first thing you constructed it with
</li>
<li>returns a new stream, putting the second thing you constructed it
with at the head.
</li>
</ul>

<p>
An imaginary repl session may make this clearer:
</p>
<div class="org-src-container">

<pre class="src src-clojure">&gt; (<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">a</span> #(make-stream (+ 1 1)))
&gt; (<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">b</span> #(stream (+ 10 20))
&gt; (<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">s</span> (merge-streams a b))
#(merge-streams #(make-stream (+ 10 20) (#(make-stream (+ 1 1))))

&gt; (<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">s</span>' (s))
#(merge-streams (<span style="color: #228b22;">StreamNode.</span> 2 <span style="color: #008b8b;">nil</span>) (#(make-stream (+ 10 20))))

&gt; (<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">s</span>'' (s'))
(<span style="color: #228b22;">StreamNode.</span> 2 (<span style="color: #228b22;">StreamNode.</span> 30))
</pre>
</div>
</div>
</li>

<li><a id="sec-2-4-5-2" name="sec-2-4-5-2"></a>Mapping<br  /><div class="outline-text-5" id="text-2-4-5-2">
<p>
<code>mapcat-stream</code> is somewhat simpler.
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #228b22;">clojure.lang.IFn</span>
(mapcat-stream [stream g]
  #(mapcat-stream (stream) g))
</pre>
</div>

<p>
The basic concept here is pretty straightforward: make a new thunk which,
when executed later, will do some work and then mapcat <code>g</code> over the result.
</p>

<p>
<b>TODO</b>: explain why this needs to be wrapped in a thunk
</p>
</div>
</li>

<li><a id="sec-2-4-5-3" name="sec-2-4-5-3"></a>Definition<br  /><div class="outline-text-5" id="text-2-4-5-3">
<p>
Here is the whole definition of IStream for functions:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(extend-protocol <span style="color: #228b22;">IStream</span>
  <span style="color: #228b22;">clojure.lang.IFn</span>
  (merge-streams [stream-1 stream-2]
    #(merge-streams stream-2 (stream-1)))

  (mapcat-stream [stream g]
    #(mapcat-stream (stream) g))

  (realize-stream-head [stream]
    (trampoline stream))

  (stream-to-seq [stream]
    (stream-to-seq (realize-stream-head stream))))
</pre>
</div>
</div>
</li></ol>
</div>

<div id="outline-container-sec-2-4-6" class="outline-4">
<h4 id="sec-2-4-6"><span class="section-number-4">2.4.6</span> Differences from Clojure's Seq</h4>
<div class="outline-text-4" id="text-2-4-6">
<p>
This is very similar to Clojure's Seq abstraction; why not just use
that? Well, there are cases where you are combining the results of two
logic programs (with merge-streams), but one of them might
diverge. This is actually fairly easy to cause in miniKanren, if
you're not careful about the way you do recursive calls. The lazy
stream system shown here handles that case by giving each stream equal
processing time, evaluating its thunks as they come. In this sense,
lazy streams are a scheduling system for processes which may return
multiple outputs.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Goals</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Until now, we have talked about a logic program returning a set of
substitutions. This was a small lie, which we now refine into the
actual implementation.
</p>
</div>

<div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1"><span class="section-number-4">2.5.1</span> States</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
A <i>state</i> is a record containing a substitution map <b>s-map</b> and the id
of the next unused logic variable, <i>next-id</i>.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defrecord</span> <span style="color: #228b22;">State</span> [s-map next-id])

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">make-state</span> [s-map next-id] (<span style="color: #228b22;">State.</span> s-map next-id))
(<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">empty-state</span> (make-state {} 0))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">with-s-map</span> [state s-map] (assoc state <span style="color: #008b8b;">:s-map</span> s-map))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">with-next-id</span> [state next-id] (assoc state <span style="color: #008b8b;">:next-id</span> next-id))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-5-2" class="outline-4">
<h4 id="sec-2-5-2"><span class="section-number-4">2.5.2</span> Goal functions</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
A goal is a function which, given a state, returns a stream of
states. It encapsulates a logic program. Give it an input state, and
it will give you one output state for each way it can make that
program succeed, given the information in the input state.
</p>
</div>
</div>

<div id="outline-container-sec-2-5-3" class="outline-4">
<h4 id="sec-2-5-3"><span class="section-number-4">2.5.3</span> Basic goal constructors</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
Rather than dealing with goals directly, we usually use
<i>goal constructors</i>; given some parameter (usually a unification term or
another goal), they will return a goal function which closes over
it.
</p>

<p>
The most fundamental goal constructor is for unification.  Given two
terms u and v, this creates a goal that will unify them. The goal
takes an existing state and returns either a state with bindings for
the lvars in u and v (using <code>unify</code>), or returns the empty stream if
no such state exists.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">===</span> [u v]
  (<span style="color: #a020f0;">fn</span> unify-goal [{<span style="color: #008b8b;">:keys</span> [s-map] <span style="color: #008b8b;">:as</span> state}]
    (<span style="color: #a020f0;">if-let</span> [s-map' (unify u v s-map)]
      (make-stream (with-s-map state s-map'))
      empty-stream)))
</pre>
</div>

<p>
<i>call-fresh</i> will wrap <i>goal-constructor</i>, a function of a single
lvar, in a goal that allocates a new lvar from its state parameter and
passes it to <i>goal-constructor</i>. For a more practical way of using
this, see the <i>fresh</i> macro below.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">call-fresh</span> [goal-constructor]
  (<span style="color: #a020f0;">fn</span> fresh-goal [{<span style="color: #008b8b;">:keys</span> [s-map next-id] <span style="color: #008b8b;">:as</span> state}]
    (<span style="color: #a020f0;">let</span> [goal (goal-constructor (lvar next-id))]
     (goal (with-next-id state (inc next-id))))))
</pre>
</div>

<p>
Logical disjuction ('or') is done with ldisj, which constructs a new
goal that succeeds whenever <i>goal-1</i> or <i>goal-2</i> succeeds.
<code>merge-streams</code> is used on each goal's output to ensure fair
scheduling between the two.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ldisj</span> [goal-1 goal-2]
  (<span style="color: #a020f0;">fn</span> disj-goal [state]
    (merge-streams (goal-1 state) (goal-2 state))))
</pre>
</div>

<p>
Logical conjunction ('and') is done with lconj. It constructs a new
goal that succeeds when both <i>goal-1</i> and <i>goal-2</i> succeed.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">lconj</span> [goal-1 goal-2]
  (<span style="color: #a020f0;">fn</span> conj-goal [state]
    (mapcat-stream (goal-1 state) goal-2)))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Sugar</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Auxilliary macros</h3>
<div class="outline-text-3" id="text-3-1">
<p>
At this point, we have defined everything we need to do logic
programming.  But it's very inconvenient; some utility macros make the
task more bearable.
</p>

<p>
<i>delay-goal</i> will wrap the given goal in a new one which, when
executed, simply returns a thunk. Recall that goal functions return
streams, and that a function is a valid kind of stream (an immature
stream). The goal will finally be executed when the thunk is evaluated
by realize-stream-head.
</p>

<p>
This is especially useful when defining recursive goals.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">delay-goal</span> [goal]
  `(<span style="color: #a020f0;">fn</span> delayed-goal-outer [state#]
     (<span style="color: #a020f0;">fn</span> delayed-goal-inner [] (~goal state#))))
</pre>
</div>

<p>
We also define extended versions of the <code>ldisj</code> and <code>lconj</code>
functions. These handle multiple arguments, instead of just two. They
also automatically wraps each goal with <code>delay-goal</code>, so you don't
need to worry about adding delays yourself.
</p>

<p>
(This does have a performance cost, but speed is not the point of this
implementation)
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">ldisj+</span>
  ([goal] `(delay-goal ~goal))
  ([goal &amp; goals] `(ldisj (delay-goal ~goal) (ldisj+ ~@goals))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">lconj+</span>
  ([goal] `(delay-goal ~goal))
  ([goal &amp; goals] `(lconj (delay-goal ~goal) (lconj+ ~@goals))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Reificiation</h3>
<div class="outline-text-3" id="text-3-2">
<p>
In miniKanren, reification refers to extracting the desired values
from the stream of states you get as a result of executing a goal.
</p>

<p>
When there are logic variables in the output which were not assigned
a value, they are named "_.0", "_.1", and so on.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">reify-name</span> [n]
  (symbol (str <span style="color: #8b2252;">"_."</span> n)))
</pre>
</div>

<p>
<i>reify-s-map</i> creates a substitution map with reified values in it. It bases
This on the supplied <i>s-map</i> parameter, but adds entries for each unknown
that appears in the <i>v</i> parameter, using values from <i>reify-name</i>.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">reify-s</span> [v s-map]
  (reify-s* (walk v s-map) s-map))

(extend-protocol <span style="color: #228b22;">IReifySubstitution</span>
  <span style="color: #228b22;">LVar</span>
  (reify-s* [v s-map] (<span style="color: #a020f0;">let</span> [n (reify-name (count s-map))]
                        (add-substitution s-map v n)))

  <span style="color: #228b22;">Object</span>
  (reify-s* [v s-map] s-map)

  <span style="color: #008b8b;">nil</span>
  (reify-s* [v s-map] s-map))
</pre>
</div>

<p>
<i>deep-walk</i> is like walk, but instead of simply returning any
non-lvar value, it will attempt to assign values to any lvars
embedded in it.  For example, <code>(deep-walk a {a (1 2 c), c 3)}</code> will
give <code>(1 2 3)</code>.  (once we have the sequence extensions, which are
defined below)
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">deep-walk</span> [v s-map]
  (deep-walk* (walk v s-map) s-map))

(extend-protocol <span style="color: #228b22;">IDeepWalk</span>
  <span style="color: #228b22;">LVar</span>   (deep-walk* [v s-map] v)
  <span style="color: #228b22;">Object</span> (deep-walk* [v s-map] v)
  <span style="color: #008b8b;">nil</span>    (deep-walk* [v s-map] v))
</pre>
</div>

<p>
Finally, we can define the actual reifier. Given a state, this will
give you the reified value of the first lvar that was defined. If
you're using the <i>run</i> macro defined below, this will be your query
variable.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">reify-state-first-var</span> [{<span style="color: #008b8b;">:keys</span> [s-map]}]
  (<span style="color: #a020f0;">let</span> [v (deep-walk (lvar 0) s-map)]
    (deep-walk v (reify-s v {}))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Programmer interface</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Define the regular miniKanren <code>conde</code> form, a disjunction of
conjunctions (an 'or' of 'ands'). Supposing that <i>a</i> and <i>b</i> are
lvars,
</p>

<div class="org-src-container">

<pre class="src src-clojure">(conde
  [(=== a 1) (=== b 2)]
  [(=== a 7) (=== b 12)})
</pre>
</div>

<p>
will produce two results: <code>{a 1, b 2}</code> and <code>{a 7, b 12}</code>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">conde</span>
  [&amp; clauses]
  `(ldisj+ ~@(map (<span style="color: #a020f0;">fn</span> [clause]
                    `(lconj+ ~@clause))
                  clauses)))
</pre>
</div>

<p>
The <code>fresh</code> macro provides a more convenient syntax for
<code>call-fresh</code>. <code>fresh</code> lets you declare multiple logic variables at
once, and it takes care of the function declaration mechanics for you.
</p>

<p>
The body of fresh is passed to <code>lconj+</code>, a logical 'and'.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(fresh [x y
  (=== x 1)
  (=== y 2))
</pre>
</div>

<p>
Will give one result, <code>{x 1, y 2}</code>.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">fresh</span>
  [var-vec &amp; clauses]
  (<span style="color: #a020f0;">if</span> (empty? var-vec)
    `(lconj+ ~@clauses)
    `(call-fresh (<span style="color: #a020f0;">fn</span> [~(first var-vec)]
                   (fresh [~@(rest var-vec)]
                     ~@clauses)))))
</pre>
</div>

<p>
A utility to invoke a goal with an empty state, as you might do
when running a logic program from scratch:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">call-empty-state</span> [goal]
  (goal empty-state))
</pre>
</div>

<p>
Finally, the run* macro gives us a lazy sequence of readable (reified) values.
</p>
<div class="org-src-container">

<pre class="src src-clojure">&gt; (run* [q]
    (conde
      [(=== q 1)]
      [(=== q 7)]))
(1 7)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">run*</span> [fresh-var-vec &amp; goals]
  `(<span style="color: #a020f0;">-&gt;&gt;</span> (fresh [~@fresh-var-vec] ~@goals)
     call-empty-state
     stream-to-seq
     (map reify-state-first-var)))
</pre>
</div>

<p>
If you only want a few values (for example, if you know there are an
infinite number of results), (run n [q] <a id="goals" name="goals"></a>) can do that. It's
equivalent to running <code>take</code> on the output of run*.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">run</span> [n fresh-var-vec &amp; goals]
  `(take ~n (run* ~fresh-var-vec ~@goals)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Sequences</h2>
<div class="outline-text-2" id="text-4">
<p>
The base logic programming system has unification and reification
support for only lvars and basic values. But it's done in an
extensible way. We'll now proceed to add sequence support to the base
language.
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Extending the core</h3>
<div class="outline-text-3" id="text-4-1">
<p>
When we unify sequences, we'd like to be able to indicate that an lvar
should be associated with the tail of a sequence. In the scheme
implementation, this is easy: by placing an lvar in the tail position
of a linked list node (the cdr position of a cons node), the
unification happens naturally when walking down the list.
</p>

<p>
Since Clojure disallows putting non-list items in linked-list cells
(so-called 'improper lists'), we have to find another way to do
it. core.logic solves this problem by defining its own LCons data type
which does allow improper lists. We take a different approach here.
</p>

<p>
Whenver you want an improper list in the context of a logic program,
you can signify it with the 'dot' sigil. For example: <code>[1 2 dot a]</code>.
This is meant to evoke the Scheme and Common LISP notation for
improper lists: <code>(1 2 . 3)</code>. This will typically be transparent to the
user on the programming side, since such lists will be automatically
constructed by the 'conso' goal below.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">deftype</span> <span style="color: #228b22;">Dot</span> [])
(<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">dot</span> (<span style="color: #228b22;">Dot.</span>))
</pre>
</div>

<p>
There are times when the user may see an improper list as the result
of a query. In this case, print the sigil as "."
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-method</span> <span style="color: #228b22;">Dot</span> [l ^<span style="color: #228b22;">java.io.Writer</span> w]
  (<span style="color: #483d8b;">.write</span> w <span style="color: #8b2252;">"."</span>))
</pre>
</div>

<p>
The first extension point is the unifier; we need to define what it means
to unify a sequence with something else.
</p>

<p>
The basic case is simple: if unifying a sequence with another sequence,
then we should unify each element together. Recursively, this means unifying
their first elements and then the rest of the sequence.
</p>

<p>
The unifier also needs to be aware of the dot-notation described
above. If either <i>u</i> or <i>v</i> is a sequence beginning with a dot, the
its second item must be an lvar which should be unified with the other
variable. For example, if we start with <code>(=== [1 2 3] [1 . a])</code>, it
will recurse down to <code>(=== [2 3] [. a])</code>. Detecting that, we can call
<code>(=== [2 3] a)</code>, which gives the desired result.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(extend-protocol <span style="color: #228b22;">IUnifyTerms</span>
  <span style="color: #228b22;">clojure.lang.Sequential</span>
  (unify-terms [u v s]
    (<span style="color: #a020f0;">cond</span>
      (= dot (first u)) (unify (second u) v s)
      (= dot (first v)) (unify u (second v) s)
      (seq v) (<span style="color: #a020f0;">-&gt;&gt;</span> s
                (unify (first u) (first v))
                (unify (rest u) (rest v))))))
</pre>
</div>

<p>
Next, we need to extend the reifier. When calling reify-s, we need to
look for occurences of logic variables inside of given paramter. This
extends reify-s to make a recursive call on the first element of the
sequence, then on the remaining elements.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(extend-protocol <span style="color: #228b22;">IReifySubstitution</span>
  <span style="color: #228b22;">clojure.lang.Sequential</span>
  (reify-s* [v s-map]
    (<span style="color: #a020f0;">if</span> (seq v)
      (reify-s (rest v) (reify-s (first v) s-map))
      s-map)))
</pre>
</div>

<p>
Deep-walk needs to be extended as well. As above, we we handle
sequences beginning with 'dot' as a special case, go recursing back
with the second item of the sequence.  For any other sequences, we
effectively map the deep-walk function over the sequence.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(extend-protocol <span style="color: #228b22;">IDeepWalk</span>
  <span style="color: #228b22;">clojure.lang.Sequential</span>
  (deep-walk* [v s-map]
    (<span style="color: #a020f0;">cond</span>
      (<span style="color: #a020f0;">and</span> (= dot (first v))
           (sequential? (second v)))
      (deep-walk (second v) s-map)

      (seq v)
      (cons (deep-walk (first v) s-map)
            (deep-walk (rest v)  s-map))

      <span style="color: #008b8b;">:default</span> v)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Sequence relations</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Now we can define some user-level relations for sequences. First,
conso says that <i>out</i> is the sequence with the head <i>first</i> and the
tail <i>rest</i>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">conso</span> [first rest out]
  (<span style="color: #a020f0;">if</span> (lvar? rest)
    (=== [first dot rest] out)
    (=== (cons first rest) out)))
</pre>
</div>

<p>
<i>firsto</i> simply says that <i>first</i> is the head of <i>out</i>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">firsto</span> [first out]
  (fresh [rest]
    (conso first rest out)))
</pre>
</div>

<p>
And <i>resto</i>, likewise, says that <i>rest</i> is the tail of <i>out</i>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">resto</span> [rest out]
  (fresh [first]
    (conso first rest out)))
</pre>
</div>

<p>
<i>emptyo</i> is a way to say that <i>s</i> must be an empty sequence.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">emptyo</span> [s]
  (=== '() s))
</pre>
</div>

<p>
<i>appendo</i> says that <i>out</i> is the result of appending the sequence parameters
<i>seq1</i> and <i>seq1</i>.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">appendo</span> [seq1 seq2 out]
  (conde
    [(emptyo seq1) (=== seq2 out)]
    [(fresh [first rest rec]
       (conso first rest seq1)
       (conso first rec out)
       (appendo rest seq2 rec))]))
</pre>
</div>

<p>
You can do some interesting things with <i>appendo</i>. For example, this program
will find all the ways you can append two lists to create <code>[1 2 3 4 5]</code>:
</p>

<div class="org-src-container">

<pre class="src src-clojure">&gt; (run* [q]
    (fresh [x y]
      (appendo x y [1 2 3 4 5])
      (=== q [x y])))

((() (1 2 3 4 5))
 ((1)  (2 3 4 5))
 ((1 2)  (3 4 5))
 ((1 2 3)  (4 5))
 ((1 2 3 4)  (5))
 ((1 2 3 4 5) ()))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Back matter</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Bibliography</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>The microKanren paper: <a href="http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf">http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf</a>
</li>
<li>The microKanren scheme implementation: <a href="https://github.com/jasonhemann/microKanren">https://github.com/jasonhemann/microKanren</a>
</li>
<li>core.logic, Clojure's real miniKanren implementation: <a href="https://github.com/clojure/core.logic">https://github.com/clojure/core.logic</a>
</li>
<li>Will Byrd's dissertation on miniKanren: <a href="https://github.com/webyrd/dissertation-single-spaced/raw/master/thesis.pdf">https://github.com/webyrd/dissertation-single-spaced/raw/master/thesis.pdf</a>
</li>
<li>Chris Grand on the lazy stream monad, and mplus in particular: <a href="http://clj-me.cgrand.net/2012/01/30/the-reasoned-scheduler/">http://clj-me.cgrand.net/2012/01/30/the-reasoned-scheduler/</a>
</li>
<li>The Reasoned Schemer: <a href="http://mitpress.mit.edu/books/reasoned-schemer">http://mitpress.mit.edu/books/reasoned-schemer</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Differences from microKanren</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Polymorphic dispatch via protocols is used in place of `(cond)` with
type checks, where possible.
</p>

<p>
Clojure-native datatypes are used where appropriate
</p>
<ul class="org-ul">
<li>The substitution map is a clojure map instead of an alist
</li>
<li>There is an LVar defrecrord, instead of using a vector of c
</li>
<li>We have an explicit StreamNode data type, rather building on the
built-in list type
</li>
<li>Clojure doesn't allow improper lists; we emulate it with the 'dot'
sigil.
</li>
</ul>

<p>
Many names have changed to be more clojure-like:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">uKanren</th>
<th scope="col" class="left">microLogic</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">mplus</td>
<td class="left">merge-streams</td>
</tr>

<tr>
<td class="left">bind</td>
<td class="left">mapcat-stream</td>
</tr>

<tr>
<td class="left">pull</td>
<td class="left">realize-stream-head</td>
</tr>

<tr>
<td class="left">mzero</td>
<td class="left">empty-stream</td>
</tr>

<tr>
<td class="left">unit</td>
<td class="left">stream</td>
</tr>

<tr>
<td class="left">Zzz</td>
<td class="left">delay-goal</td>
</tr>

<tr>
<td class="left">conj</td>
<td class="left">lconj</td>
</tr>

<tr>
<td class="left">disj</td>
<td class="left">ldisj</td>
</tr>

<tr>
<td class="left">==</td>
<td class="left"><code>===</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Differences from core.logic</h3>
<div class="outline-text-3" id="text-5-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">core.logic</th>
<th scope="col" class="left">microLogic</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">mplus</td>
<td class="left">merge-streams</td>
</tr>

<tr>
<td class="left">bind</td>
<td class="left">mapcat-stream</td>
</tr>

<tr>
<td class="left">pull</td>
<td class="left">realize-stream-head</td>
</tr>

<tr>
<td class="left">mzero</td>
<td class="left">empty-stream</td>
</tr>

<tr>
<td class="left">unit</td>
<td class="left">stream</td>
</tr>

<tr>
<td class="left">==</td>
<td class="left"><code>===</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Russell Mull</p>
<p class="date">Created: 2014-12-30 Tue 10:36</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
