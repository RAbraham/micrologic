<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>microLogic</title>
<!-- 2014-12-31 Wed 00:51 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Russell Mull" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-light.min.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">microLogic</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a></li>
<li><a href="#sec-2">2. Functional Core</a>
<ul>
<li><a href="#sec-2-1">2.1. Logic Variables</a></li>
<li><a href="#sec-2-2">2.2. Substitutions and Walking</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1. Adding entries</a></li>
<li><a href="#sec-2-2-2">2.2.2. Looking up values</a></li>
</ul>
</li>
<li><a href="#sec-2-3">2.3. Unification</a></li>
<li><a href="#sec-2-4">2.4. Lazy Streams</a>
<ul>
<li><a href="#sec-2-4-1">2.4.1. Motivation</a></li>
<li><a href="#sec-2-4-2">2.4.2. Definition of a lazy stream</a></li>
<li><a href="#sec-2-4-3">2.4.3. Empty stream</a></li>
<li><a href="#sec-2-4-4">2.4.4. Mature streams (StreamNode)</a></li>
<li><a href="#sec-2-4-5">2.4.5. Immature streams (IFn)</a></li>
<li><a href="#sec-2-4-6">2.4.6. Differences from Clojure's lazy sequences</a></li>
</ul>
</li>
<li><a href="#sec-2-5">2.5. Goals</a>
<ul>
<li><a href="#sec-2-5-1">2.5.1. Interpreter state</a></li>
<li><a href="#sec-2-5-2">2.5.2. Goal functions</a></li>
<li><a href="#sec-2-5-3">2.5.3. Basic goal constructors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. Sugar</a>
<ul>
<li><a href="#sec-3-1">3.1. Auxilliary macros</a></li>
<li><a href="#sec-3-2">3.2. Reificiation</a></li>
<li><a href="#sec-3-3">3.3. Programmer interface</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Sequences</a>
<ul>
<li><a href="#sec-4-1">4.1. Extending the core</a></li>
<li><a href="#sec-4-2">4.2. Sequence goals</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Back matter</a>
<ul>
<li><a href="#sec-5-1">5.1. Bibliography</a></li>
<li><a href="#sec-5-2">5.2. Differences from microKanren</a></li>
<li><a href="#sec-5-3">5.3. Differences from core.logic</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
This is a literate Clojure implementation of miniKanren, a logic
programming system which can be embedded in functional programming
languages.  It's meant to be an introduction to the inner workings of
miniKanren and and of core.logic, helping you to understand more
completely what's happening when you use those systems.
</p>

<p>
For maximum enjoyment, the reader should be familiar with Clojure, and
in particular with protocols. In lieu of that, basic understanding of
lisp syntax and a read through something like
<a href="http://clojure-doc.org/articles/language/polymorphism.html">http://clojure-doc.org/articles/language/polymorphism.html</a> should be
sufficient.
</p>

<p>
This code was derived substantially from microKanren; for much more
information, see the bibliography at the end.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Functional Core</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Logic Variables</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The purpose of a logic program is to takes an expression with some
unknowns in it and try to find values for those unknowns that make the
espression true. Here's an example logic program in English with an
unknown <i>x</i>:
</p>

<pre class="example">
Either x is the beginning of the list ["banana", "orange", "apple"],
or x is the number 1.
</pre>

<p>
(The two values of <i>x</i> that make this expression true are <code>1</code> and <code>banana</code>)
</p>

<p>
These unknowns are called <i>logic variables</i>, or <i>lvars</i> for
short. Since we're going to write our logic programs in Clojure, we
need a way to represent them in that context.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defrecord</span> <span style="color: #228b22;">LVar</span> [id])
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">lvar</span> [id] (<span style="color: #228b22;">LVar.</span> id))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">lvar?</span> [x] (instance? <span style="color: #228b22;">LVar</span> x))
</pre>
</div>

<p>
An lvar's <i>id</i> could be anything, but we use it like a serial
number. The first lvar gets created with id 0, the next with id 1, and
so on. There is some special syntax to help with that, which we'll see
later on.
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Substitutions and Walking</h3>
<div class="outline-text-3" id="text-2-2">
<p>
In the course of running a logic program, we'll be deciding on values
for logic variables and testing those values against other parts of
the program to see if it meets all the neccessary criteria. The values
are stored in a data structure called a substitution map (<i>s-map</i> for
short).
</p>

<p>
A substitution map is just a regular clojure hash-map with lvars as
its keys. Again consider this example:
</p>

<pre class="example">
Either x is the beginning of the list ["banana", "orange", "apple"],
or x is the number 1.
</pre>

<p>
<code>{ (lvar 0) "banana" }</code> is one substitution map that will make this
expression true (as long as <i>x</i> is lvar 0).
</p>

<p>
There is a twist to the substitution map: in addition to regular
values, lvars can be used in the value position as well. (This is
called a <i>triangular</i> substitution) Here is an example which implies
a triangular substitution:
</p>

<pre class="example">
x is the beginning of the list [y, "orange", "apple"].
y is the string "banana".
</pre>

<p>
One substitution map which makes this expression true is
</p>
<div class="org-src-container">

<pre class="src src-clojure">{ (lvar 0) (lvar 1)
  (lvar 1) <span style="color: #8b2252;">"banana"</span> }
</pre>
</div>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> Adding entries</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
Although a substitution map is nothing but a regular clojure map, we
need some utility functions to deal with some subtleties of its behavior.
The first is for adding add new entries:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">add-substitution</span> [s-map lvar value]
  (<span style="color: #a020f0;">when</span> s-map
    (assoc s-map lvar value)))
</pre>
</div>

<p>
If you try to add something to a <code>nil</code> substitution map, we just
return <code>nil</code>. The <code>nil</code> substitution map is output when there are no
substitutions that can make an expression true. We'll see where
this is important when we start to build up substitution maps.
</p>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> Looking up values</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
The other thing we do with a substitution map is to look up what value
is associated with an lvar. It's just a hash-map, so why don't we just
use the <code>get</code> function for this? Two reasons:
</p>

<ol class="org-ol">
<li>If there is an lvar on the right-hand side, we need to look up that
value, following such references until we get to a non-lvar.
</li>

<li>The operation we want is actually "give me the value of this
object, given this substitution map". So if you call it with a
value that's not an lvar, it should just give you that value back.
</li>
</ol>

<p>
The function is called <i>walk</i>, since it follows lvar references on the
right-hand side.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(extend-protocol <span style="color: #228b22;">IWalk</span>
  <span style="color: #228b22;">LVar</span>
  (walk [u s-map] (<span style="color: #a020f0;">if-let</span> [val (get s-map u)]
                    (<span style="color: #a020f0;">recur</span> val s-map)
                    u))
  <span style="color: #228b22;">Object</span>
  (walk [u s-map] u)

  <span style="color: #008b8b;">nil</span>
  (walk [u s-map] <span style="color: #008b8b;">nil</span>))
</pre>
</div>

<p>
Here are some example <code>walk</code> invocations:
</p>
<div class="org-src-container">

<pre class="src src-clojure">&gt; (<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">s-map</span> { (lvar 0) (lvar 1)
               (lvar 1) <span style="color: #8b2252;">"banana"</span> })

&gt; (walk (lvar 0) s-map)
<span style="color: #8b2252;">"banana"</span>

&gt; (walk (lvar 1) s-map)
<span style="color: #8b2252;">"banana"</span>

&gt; (walk <span style="color: #8b2252;">"mango"</span> s-map)
<span style="color: #8b2252;">"mango"</span>
</pre>
</div>


<p>
You might notice that it is easy to construct a substitution map with
a loop in it: <code>(walk a {a b, b a})</code> will not terminate. Most implementations
would handle that with a check in <code>add-substitution</code>, but we omit it here
for simplicity.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Unification</h3>
<div class="outline-text-3" id="text-2-3">
<p>
<code>unify</code> is the way we build up substitution maps. Given two terms <i>u</i>
and <i>v</i>, and an existing substitution map <i>s-map</i>, <code>unify</code> produces a
new substitution map with mappings that will make u and v equal.
</p>

<p>
A term is simply somthing you can pass to unify. This is indeed a
circular definition. But really, you can pass anything you like as a
term. It's just that some types of terms have specialized behavior.
LVars do, for example. When we add support for sequences, they will as
well. Anything not handled explicitly is still a valid term, but it's
just treated as an opaque value.
</p>

<p>
Let's walk through some examples.
</p>

<ul class="org-ul">
<li>First, if either <i>u</i> or <i>v</i> is an lvar, the unifying them with a
value just like assigning a value to that lvar in the substitution
map.

<div class="org-src-container">

<pre class="src src-clojure">&gt; (unify (lvar 0) <span style="color: #8b2252;">"banana"</span> {})
{(lvar 0) <span style="color: #8b2252;">"banana"</span>}

&gt; (unify <span style="color: #8b2252;">"banana"</span> (lvar 0) {})
{(lvar 0) <span style="color: #8b2252;">"banana"</span>}
</pre>
</div>
</li>

<li>But what if the lvar already has a value? Then there are two
possibilities. Either the two values agree:
<div class="org-src-container">

<pre class="src src-clojure">&gt; (unify (lvar 0) <span style="color: #8b2252;">"banana"</span>
         {(lvar 0) <span style="color: #8b2252;">"banana"</span>})
{(lvar 0) <span style="color: #8b2252;">"banana"</span>}
</pre>
</div>

<p>
Or they do not, leading to a contradiction:
</p>
<div class="org-src-container">

<pre class="src src-clojure">&gt; (unify (lvar 0) <span style="color: #8b2252;">"banana"</span>
         {(lvar 0) <span style="color: #8b2252;">"mango"</span>})
<span style="color: #008b8b;">nil</span>
</pre>
</div>
</li>

<li>When there's something un-related in the substitution map,
we'll just add to it:
<div class="org-src-container">

<pre class="src src-clojure">&gt; (unify (lvar 0) <span style="color: #8b2252;">"banana"</span>
         {(lvar 9) <span style="color: #8b2252;">"squirrels"</span>})
{(lvar 0) <span style="color: #8b2252;">"banana"</span>
 (lvar 9) <span style="color: #8b2252;">"squirrels"</span>}
</pre>
</div>
</li>
</ul>

<p>
That's it for the basic cases. They seem pretty trivial, but our unifier has
one more nice feature: extensibility. By extending the IUnifyTerms protocol,
you can add specialized unification behavior for any other data type as well.
For example, once we add support for sequences below you'll be able to do this:
</p>

<div class="org-src-container">

<pre class="src src-clojure">&gt; (unify [(lvar 0) 2 3] [<span style="color: #8b2252;">"banana"</span> 2 3] {})
{(lvar 0) <span style="color: #8b2252;">"banana"</span>}
</pre>
</div>

<p>
Here's the implementation of <code>unify</code>:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">unify</span> [u v s-map]
  (<span style="color: #a020f0;">let</span> [u (walk u s-map),    v (walk v s-map)
        u-is-lvar (lvar? u), v-is-lvar (lvar? v)]
    (<span style="color: #a020f0;">cond</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">Unifying two lvars adds no information to the substitution map</span>
      (<span style="color: #a020f0;">and</span> u-is-lvar v-is-lvar (= u v)) s-map

      <span style="color: #b22222;">;; </span><span style="color: #b22222;">Unifying an lvar with some other value creates a new entry in</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">the substitution map</span>
      u-is-lvar (add-substitution s-map u v)
      v-is-lvar (add-substitution s-map v u)

      <span style="color: #b22222;">;; </span><span style="color: #b22222;">two non-lvar values always unify if they're equal</span>
      (= u v) s-map

      <span style="color: #b22222;">;; </span><span style="color: #b22222;">Unifying two non-lvars is delegated to the polymorphic</span>
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">unify-terms function, from IUnifyTerms.</span>
      <span style="color: #008b8b;">:default</span> (unify-terms u v s-map))))
</pre>
</div>

<p>
Here are the basic IUnifyTerms definitions for Object and nil.  If we
get dispatched to either of these definitions, we know that neither u
or v is an lvar, that the values aren't equal, and we aren't doing
some kind of extended unification that's defined elsewhere. Thus, they
must not unify.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(extend-protocol <span style="color: #228b22;">IUnifyTerms</span>
  <span style="color: #228b22;">Object</span> (unify-terms [u v s-map] <span style="color: #008b8b;">nil</span>)
  <span style="color: #008b8b;">nil</span>    (unify-terms [u v s-map] <span style="color: #008b8b;">nil</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Lazy Streams</h3>
<div class="outline-text-3" id="text-2-4">
<p>
As we've alluded to above, when you run a logic program you can get more than
one result. MiniKanren's approach to this is really unique, and is one
of the most interesting parts of the program.
</p>
</div>

<div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> Motivation</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
First, I'll try to convince you that we need to make a special lazy
stream mechanism. We'll start with a more formal definition of what we
mean by a "logic program":
</p>

<p>
<b>THE DEFINITION OF A LOGIC PROGRAM</b>
</p>

<ol class="org-ol">
<li>In miniKanren, <i>the output of a logic program is a set of
substitutions</i> that make that program true.
</li>

<li>A logic program is built by combining smaller logic programs using
the conjunction (and) and disjunction (or) operators.
</li>
</ol>

<p>
Now, let's consider this logic program in particular:
</p>
<pre class="example">
Define Natural(x) to be true when either:
  - x is the number 0
  - x is greater than 0, and Natural(x - 1) is true
</pre>

<p>
Clearly there are an infinite number of substitution maps that make
this program true - <code>{(lvar 0) 0}</code>, <code>{(lvar 0) 1}</code>, <code>{(lvar 0) 2}</code>,
and so on. That is, it has an inifinitely large set of solutions.
</p>

<p>
Here's another motivating example:
</p>
<pre class="example">
Define Diverge(x) to be true when Diverge(x) is true
</pre>

<p>
As you can probably guess from the name, this is a program which has
no valid output. But it's a program you can write all the same, and it
will take forever to produce no output. The example is contrived, but
you can get into such a situation surprisingly (distressingly) easily
when writing actual progrems.
</p>

<p>
So we now know that:
</p>
<ol class="org-ol">
<li>There are logic programs with infinitely many solutions
</li>
<li>There are logic programs which diverge
</li>
</ol>

<p>
And, we want to compose such programs together in a sane way, to make
more complex programs. We need a way to fairly take results from
programs with infinitely many solutions, and to continue to service a
part of the program which might diverge while continuing to work on
its more productive brethren.
</p>

<p>
This is the motivation for lazy streams.
</p>
</div>
</div>

<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> Definition of a lazy stream</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
There are three kinds of lazy streams:
</p>
<ul class="org-ul">
<li>Empty
</li>
<li>Mature (head realized)
</li>
<li>Immature (head unrealized)
</li>
</ul>

<p>
A mature stream is one in which the first element of the stream has a
definite value that has already been computed. An immature stream, on
the other hand, does not yet have a computed head. Instead if has a
function which it can used to compute a mature (or empty) stream when
you need it.
</p>

<p>
You can manipulate a stream with these functions:
</p>
<ul class="org-ul">
<li>Merge two of them together with <code>merge-streams</code>
</li>
<li>Map a function over it with <code>mapcat-stream</code>, as long as that
function itself produces streams.
</li>
<li>Realize its head with <code>realize-stream-head</code>. This will transition it
to either immature or empty, performing any necessary work along the
way.
</li>
<li>Convert it to a Clojure lazy sequence, with <code>stream-to-seq</code>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3"><span class="section-number-4">2.4.3</span> Empty stream</h4>
<div class="outline-text-4" id="text-2-4-3">
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">empty-stream</span>
  (reify <span style="color: #228b22;">IStream</span>
    (merge-streams [this other-stream] other-stream)
    (mapcat-stream [this g] this)
    (realize-stream-head [this] this)
    (stream-to-seq [this] '())))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-4" class="outline-4">
<h4 id="sec-2-4-4"><span class="section-number-4">2.4.4</span> Mature streams (StreamNode)</h4>
<div class="outline-text-4" id="text-2-4-4">
<p>
A mature streams is represented by an instance of StreamNode.  This is
kind of like a linked list: <i>head</i> is the realized value that can be
taken from the stream, and <i>next</i> is the stream which follows.  But
these streams are polymorphic; <i>next</i> isn't necessarily a StreamNode,
just some other thing which extends the IStream protocol.
</p>

<p>
Note that if we have only StreamNodes (i.e. fully realized streams),
<code>merge-streams</code> is equivalent to <code>concat</code> and <code>mapcat-stream</code> to
<code>mapcat</code>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">deftype</span> <span style="color: #228b22;">StreamNode</span> [head next]
  <span style="color: #228b22;">IStream</span>
  (merge-streams [this other-stream] (<span style="color: #228b22;">StreamNode.</span> head
                                                  (merge-streams next other-stream)))
  (mapcat-stream [this g] (merge-streams (g head)
                                         (mapcat-stream next g)))
  (realize-stream-head [this] this)

  (stream-to-seq [this] (lazy-seq (cons head (stream-to-seq next)))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">make-stream</span> [s] (<span style="color: #228b22;">StreamNode.</span> s empty-stream))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-5" class="outline-4">
<h4 id="sec-2-4-5"><span class="section-number-4">2.4.5</span> Immature streams (IFn)</h4>
<div class="outline-text-4" id="text-2-4-5">
<p>
An immature stream is represented by a thunk (a function of no
arguments).
</p>

<p>
Executing the thunk does one unit of work and returns a new
stream. This may in turn be a function, so you might have to keep
calling the returned function many times until you get down to a
realized value. This is exactly what <code>realize-stream-head</code> does here,
by way of <code>trampoline</code>.
</p>
</div>

<ol class="org-ol"><li><a id="sec-2-4-5-1" name="sec-2-4-5-1"></a>Merging<br  /><div class="outline-text-5" id="text-2-4-5-1">
<p>
Merging is tricky - this is the code that interleaves values from two
infinite streams, and what makes sure a branch that diverges doesn't
tie up the whole program.
</p>
<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #228b22;">clojure.lang.IFn</span>
(merge-streams [this other-stream]
  #(merge-streams other-stream (this)))
</pre>
</div>

<p>
Working from the inside out: we know that 'this' is a function because
we're extending IStream onto IFn; calling it will perform one 'unit of
work', whatever that might be. It returns a stream.  Then we merge
that stream with other-stream, the second parameter of this merge
operation, <i>but the order is reversed</i>.
</p>

<p>
Finally, the above operation is all wrapped in a thunk. So we end up with a
function that:
</p>

<ul class="org-ul">
<li>performs the work for the first thing you constructed it with
</li>
<li>returns a new stream, putting the second thing you constructed it
with at the head.
</li>
</ul>

<p>
An imaginary repl session may make this clearer:
</p>
<div class="org-src-container">

<pre class="src src-clojure">&gt; (<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">a</span> #(make-stream (+ 1 1)))
&gt; (<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">b</span> #(stream (+ 10 20))
&gt; (<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">s</span> (merge-streams a b))
#(merge-streams #(make-stream (+ 10 20) (#(make-stream (+ 1 1))))

&gt; (<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">s</span>' (s))
#(merge-streams (<span style="color: #228b22;">StreamNode.</span> 2 <span style="color: #008b8b;">nil</span>) (#(make-stream (+ 10 20))))

&gt; (<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">s</span>'' (s'))
(<span style="color: #228b22;">StreamNode.</span> 2 (<span style="color: #228b22;">StreamNode.</span> 30))
</pre>
</div>
</div>
</li>

<li><a id="sec-2-4-5-2" name="sec-2-4-5-2"></a>Mapping<br  /><div class="outline-text-5" id="text-2-4-5-2">
<p>
<code>mapcat-stream</code> is somewhat simpler.
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #228b22;">clojure.lang.IFn</span>
(mapcat-stream [this g]
  #(mapcat-stream (this) g))
</pre>
</div>

<p>
The basic concept here is pretty straightforward: make a new thunk
which, when executed later, will do some work and then mapcat <code>g</code> over
the result.  The thunk is used instead of just exeuting the function
directly because <code>mapcat-stream</code> may be used inside a recusive
function, which might diverge. This won't keep the function from
diverging, but it will allow its execution to be interleaved with the
rest of the program.
</p>
</div>
</li>

<li><a id="sec-2-4-5-3" name="sec-2-4-5-3"></a>Definition<br  /><div class="outline-text-5" id="text-2-4-5-3">
<p>
Here is the whole definition of IStream for functions:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(extend-protocol <span style="color: #228b22;">IStream</span>
  <span style="color: #228b22;">clojure.lang.IFn</span>
  (merge-streams [this other-stream]
    #(merge-streams other-stream (this)))

  (mapcat-stream [this g]
    #(mapcat-stream (this) g))

  (realize-stream-head [this]
    (trampoline this))

  (stream-to-seq [this]
    (stream-to-seq (realize-stream-head this))))
</pre>
</div>
</div>
</li></ol>
</div>

<div id="outline-container-sec-2-4-6" class="outline-4">
<h4 id="sec-2-4-6"><span class="section-number-4">2.4.6</span> Differences from Clojure's lazy sequences</h4>
<div class="outline-text-4" id="text-2-4-6">
<p>
This is very similar to Clojure's lazy sequence facility; why not just
use that? Well, there are cases where you are combining the results of
two logic programs (with merge-streams), but one of them might
diverge. (Remember the example above?) The lazy stream system shown
here handles that case by giving each stream equal processing time,
evaluating its thunks as they come. In this sense, lazy streams are a
scheduling system for processes which may return multiple outputs.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Goals</h3>
<div class="outline-text-3" id="text-2-5">
<p>
I told you before that the output of a logic program is a set of
substitutions. That was a small lie, which we will now refine into the
actual implementation.
</p>
</div>

<div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1"><span class="section-number-4">2.5.1</span> Interpreter state</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
A <i>state</i> is a record containing a substitution map <b>s-map</b> and the id
of the next unused logic variable, <i>next-id</i>.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defrecord</span> <span style="color: #228b22;">State</span> [s-map next-id])

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">make-state</span> [s-map next-id] (<span style="color: #228b22;">State.</span> s-map next-id))
(<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">empty-state</span> (make-state {} 0))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">with-s-map</span> [state s-map] (assoc state <span style="color: #008b8b;">:s-map</span> s-map))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">with-next-id</span> [state next-id] (assoc state <span style="color: #008b8b;">:next-id</span> next-id))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-5-2" class="outline-4">
<h4 id="sec-2-5-2"><span class="section-number-4">2.5.2</span> Goal functions</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
A goal is a function which, given a state, returns a stream of
states. It encapsulates a logic program. Give it an input state, and
it will give you one output state for each way it can make that goal
true (or <i>succeed</i> in the parlance of miniKanren and The Reasoned
Schemer), given the information in the input state.
</p>
</div>
</div>

<div id="outline-container-sec-2-5-3" class="outline-4">
<h4 id="sec-2-5-3"><span class="section-number-4">2.5.3</span> Basic goal constructors</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
Rather than dealing with goals directly, we usually use
<i>goal constructors</i>; given some parameter (usually a unification term or
another goal), they will return a goal function which closes over
it.
</p>

<p>
The most fundamental goal constructor is for unification.  Given two
terms <i>u</i> and <i>v</i>, this creates a goal that will unify them. The goal
takes an existing state and returns (as a lazy stream) either a state
with bindings for the lvars in <i>u</i> and <i>v</i> (using <code>unify</code>), or nothing
at all if <i>u</i> and <i>v</i> cannot be unified.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">===</span> [u v]
  (<span style="color: #a020f0;">fn</span> unify-goal [{<span style="color: #008b8b;">:keys</span> [s-map] <span style="color: #008b8b;">:as</span> state}]
    (<span style="color: #a020f0;">if-let</span> [s-map' (unify u v s-map)]
      (make-stream (with-s-map state s-map'))
      empty-stream)))
</pre>
</div>

<p>
<i>call-fresh</i> is a higher-order goal constructor that encapsulates the
allocation of logic variables. You pass it your own
<i>goal-constructor</i>, which takes as its single parameter the lvar that
you want to use.  <i>call-fresh</i> will make a new goal that allocates it
for you, passing it in to your code.  <i>goal-constructor</i>. For a more
convenient way to do this, see the <i>fresh</i> macro below.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">call-fresh</span> [goal-constructor]
  (<span style="color: #a020f0;">fn</span> fresh-goal [{<span style="color: #008b8b;">:keys</span> [s-map next-id] <span style="color: #008b8b;">:as</span> state}]
    (<span style="color: #a020f0;">let</span> [goal (goal-constructor (lvar next-id))]
     (goal (with-next-id state (inc next-id))))))
</pre>
</div>

<p>
One way to combine smaller goals into a new one is with logical
disjuction, the 'or' operation. <code>ldisj</code> which constructs a new goal
that succeeds whenever <i>goal-1</i> or <i>goal-2</i> succeeds.  Another way to
look at this is that it interleaves the results of <i>goal-1</i> and
<i>goal-2</i>, using <code>merge-streams</code>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ldisj</span> [goal-1 goal-2]
  (<span style="color: #a020f0;">fn</span> disj-goal [state]
    (merge-streams (goal-1 state) (goal-2 state))))
</pre>
</div>

<p>
You can also combine goals with logical conjunction, the 'and'
operation. <code>lconj</code> constructs a new goal that succeeds when both
<i>goal-1</i> and <i>goal-2</i> succeed. It does this by running goal-2 on each
output of goal-1. You can think of this as being like function
composition for functions with multiple outputs.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">lconj</span> [goal-1 goal-2]
  (<span style="color: #a020f0;">fn</span> conj-goal [state]
    (mapcat-stream (goal-1 state) goal-2)))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Sugar</h2>
<div class="outline-text-2" id="text-3">
<p>
At this point, we have everything we need to do logic programming!
But it's very inconvenient. Here we define some syntax to make the
task more bearable.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Auxilliary macros</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<i>delay-goal</i> will wrap the given goal in a new one which, when
executed, simply returns a thunk that wraps the goal. Recall that goal
functions return streams, and that a function is a valid kind of
stream (an immature stream). The goal will finally be executed when
the thunk is evaluated by realize-stream-head.
</p>

<p>
This is especially useful when defining recursive goals.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">delay-goal</span> [goal]
  `(<span style="color: #a020f0;">fn</span> delayed-goal-outer [state#]
     (<span style="color: #a020f0;">fn</span> delayed-goal-inner [] (~goal state#))))
</pre>
</div>

<p>
We also define extended versions of the <code>ldisj</code> and <code>lconj</code>
functions. These handle multiple goal parameters, instead of just
two. They also automatically wraps each goal with <code>delay-goal</code>, so you
don't need to worry about adding delays yourself.
</p>

<p>
(This does have a performance cost, but speed is not the point of this
implementation)
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">ldisj+</span>
  ([goal] `(delay-goal ~goal))
  ([goal &amp; goals] `(ldisj (delay-goal ~goal) (ldisj+ ~@goals))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">lconj+</span>
  ([goal] `(delay-goal ~goal))
  ([goal &amp; goals] `(lconj (delay-goal ~goal) (lconj+ ~@goals))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Reificiation</h3>
<div class="outline-text-3" id="text-3-2">
<p>
In miniKanren, reification refers to extracting the desired values
from the stream of states you get as a result of executing a goal.
</p>

<p>
When there are logic variables in the output which were not assigned
a value, they are named <code>_.0</code>, <code>_.1</code>, and so on.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">reify-name</span> [n]
  (symbol (str <span style="color: #8b2252;">"_."</span> n)))
</pre>
</div>

<p>
<i>reify-s-map</i> creates a substitution map with reified values in it. It
bases this on the supplied <i>s-map</i> parameter, but adds entries for
each unknown that appears in the supplied term <i>v</i>, using values from
<i>reify-name</i>.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">reify-s</span> [v s-map]
  (reify-s* (walk v s-map) s-map))

(extend-protocol <span style="color: #228b22;">IReifySubstitution</span>
  <span style="color: #228b22;">LVar</span>
  (reify-s* [v s-map] (<span style="color: #a020f0;">let</span> [n (reify-name (count s-map))]
                        (add-substitution s-map v n)))

  <span style="color: #228b22;">Object</span>
  (reify-s* [v s-map] s-map)

  <span style="color: #008b8b;">nil</span>
  (reify-s* [v s-map] s-map))
</pre>
</div>

<p>
<i>deep-walk</i> is like walk, but instead of simply returning any
non-lvar value, it will attempt to assign values to any lvars
embedded in it.  For example, <code>(deep-walk a {a (1 2 c), c 3)}</code> will
give <code>(1 2 3)</code>. (once we have the sequence extensions, which are
defined below)
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">deep-walk</span> [v s-map]
  (deep-walk* (walk v s-map) s-map))

(extend-protocol <span style="color: #228b22;">IDeepWalk</span>
  <span style="color: #228b22;">LVar</span>   (deep-walk* [v s-map] v)
  <span style="color: #228b22;">Object</span> (deep-walk* [v s-map] v)
  <span style="color: #008b8b;">nil</span>    (deep-walk* [v s-map] v))
</pre>
</div>

<p>
Finally, we can define the actual reifier. Given a state, this will
give you the reified value of the first lvar that was defined. If
you're using the <i>run</i> macro defined below, this will be the first
query variable.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">reify-state-first-var</span> [{<span style="color: #008b8b;">:keys</span> [s-map]}]
  (<span style="color: #a020f0;">let</span> [v (deep-walk (lvar 0) s-map)]
    (deep-walk v (reify-s v {}))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Programmer interface</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Define the regular miniKanren <code>conde</code> form, a disjunction of
conjunctions (an 'or' of 'ands'). Supposing that <i>a</i> and <i>b</i> are
lvars,
</p>

<div class="org-src-container">

<pre class="src src-clojure">(conde
  [(=== a 1) (=== b 2)]
  [(=== a 7) (=== b 12)})
</pre>
</div>

<p>
will produce two results: <code>{a 1, b 2}</code> and <code>{a 7, b 12}</code>. (If you've
never used miniKanren or core.logic before: 'e' means 'either'. Yes,
the naming is odd. But really, it's best to remember that it's an 'or
of ands' and to get used to the name)
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">conde</span>
  [&amp; clauses]
  `(ldisj+ ~@(map (<span style="color: #a020f0;">fn</span> [clause]
                    `(lconj+ ~@clause))
                  clauses)))
</pre>
</div>

<p>
The <code>fresh</code> macro allocates some new logic variables and makes them
available in its boday. Really, it's a more convenient syntax for
<code>call-fresh</code>. <code>fresh</code> lets you declare multiple logic variables at
once, and it takes care of the function declaration mechanics for you.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">fresh</span>
  [var-vec &amp; clauses]
  (<span style="color: #a020f0;">if</span> (empty? var-vec)
    `(lconj+ ~@clauses)
    `(call-fresh (<span style="color: #a020f0;">fn</span> [~(first var-vec)]
                   (fresh [~@(rest var-vec)]
                     ~@clauses)))))
</pre>
</div>

<p>
The body of fresh is a list of goals that is passed to <code>lconj+</code>, a
logical 'and'. This goal:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(fresh [x y]
  (=== x 1)
  (=== y 2))
</pre>
</div>

<p>
Will give one result, <code>{x 1, y 2}</code>.
</p>


<p>
We define a small utility to invoke a goal with an empty state, as you
might do when running a logic program from the top:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">call-empty-state</span> [goal]
  (goal empty-state))
</pre>
</div>

<p>
Finally, the run* macro gives us a lazy sequence of readable (reified) values.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">run*</span> [fresh-var-vec &amp; goals]
  `(<span style="color: #a020f0;">-&gt;&gt;</span> (fresh [~@fresh-var-vec] ~@goals)
     call-empty-state
     stream-to-seq
     (map reify-state-first-var)))
</pre>
</div>

<p>
The first parameter is a vector of logic varialbes which will be
alocated and made available in the body; the first of these is reified
and returned as a lazy sequence. This is called the 'query variable',
and is often named 'q' by convention.
</p>

<div class="org-src-container">

<pre class="src src-clojure">&gt; (run* [q]
    (conde
      [(=== q 1)]
      [(=== q 7)]))
(1 7)
</pre>
</div>

<p>
If you only want a few values (for example, if you know there are an
infinite number of results), <code>(run n [q] &lt;&lt;goals&gt;&gt;)</code> can do that. It's
equivalent to running <code>take</code> on the output of run*.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">run</span> [n fresh-var-vec &amp; goals]
  `(take ~n (run* ~fresh-var-vec ~@goals)))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Sequences</h2>
<div class="outline-text-2" id="text-4">
<p>
The base logic programming system has unification and reification
support for only lvars and basic values. But it's done in an
extensible way. We'll now proceed to add sequence support to the base
language.
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Extending the core</h3>
<div class="outline-text-3" id="text-4-1">
<p>
When we unify sequences, we'd like to be able to indicate that an lvar
should be associated with the tail of a sequence. In the scheme
implementation, this is easy: by placing an lvar in the tail position
of a linked list node (the cdr position of a cons node), the
unification happens naturally when walking down the list.
</p>

<p>
Since Clojure disallows putting non-list items in linked-list cells
(so-called 'improper lists'), we have to find another way to do
it. core.logic solves this problem by defining its own LCons data type
which does allow improper lists. We take a different approach here.
</p>

<p>
Whenver you want an improper list in the context of a logic program,
you can signify it with the 'dot' sigil. For example: <code>[1 2 dot a]</code>.
This is meant to evoke the Scheme and Common LISP notation for
improper lists: <code>(1 2 . 3)</code>. This will typically be transparent to the
user on the programming side, since such lists will be automatically
constructed by the 'conso' goal below.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">deftype</span> <span style="color: #228b22;">Dot</span> [])
(<span style="color: #a020f0;">def</span> <span style="color: #a0522d;">dot</span> (<span style="color: #228b22;">Dot.</span>))
</pre>
</div>

<p>
There are times when the user may see an improper list as the result
of a query. In this case, print the sigil as "."
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-method</span> <span style="color: #228b22;">Dot</span> [l ^<span style="color: #228b22;">java.io.Writer</span> w]
  (<span style="color: #483d8b;">.write</span> w <span style="color: #8b2252;">"."</span>))
</pre>
</div>

<p>
The first extension point is the unifier; we need to define what it means
to unify a sequence with something else.
</p>

<p>
The basic case is simple: if unifying a sequence with another sequence,
then we should unify each element together. Recursively, this means unifying
their first elements and then the rest of the sequence.
</p>

<p>
The unifier also needs to be aware of the dot-notation described
above. If either <i>u</i> or <i>v</i> is a sequence beginning with a dot, the
its second item must be an lvar which should be unified with the other
variable. For example, if we start with <code>(=== [1 2 3] [1 . a])</code>, it
will recurse down to <code>(=== [2 3] [. a])</code>. Detecting that, we can call
<code>(=== [2 3] a)</code>, which gives the desired result.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(extend-protocol <span style="color: #228b22;">IUnifyTerms</span>
  <span style="color: #228b22;">clojure.lang.Sequential</span>
  (unify-terms [u v s]
    (<span style="color: #a020f0;">cond</span>
      (= dot (first u)) (unify (second u) v s)
      (= dot (first v)) (unify u (second v) s)
      (seq v) (<span style="color: #a020f0;">-&gt;&gt;</span> s
                (unify (first u) (first v))
                (unify (rest u) (rest v))))))
</pre>
</div>

<p>
Next, we need to extend the reifier. When calling reify-s, we need to
look for occurences of logic variables inside of given paramter. This
extends reify-s to make a recursive call on the first element of the
sequence, then on the remaining elements.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(extend-protocol <span style="color: #228b22;">IReifySubstitution</span>
  <span style="color: #228b22;">clojure.lang.Sequential</span>
  (reify-s* [v s-map]
    (<span style="color: #a020f0;">if</span> (seq v)
      (reify-s (rest v) (reify-s (first v) s-map))
      s-map)))
</pre>
</div>

<p>
Deep-walk needs to be extended as well. As above, we we handle
sequences beginning with 'dot' as a special case, go recursing back
with the second item of the sequence.  For any other sequences, we
effectively map the deep-walk function over the sequence.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(extend-protocol <span style="color: #228b22;">IDeepWalk</span>
  <span style="color: #228b22;">clojure.lang.Sequential</span>
  (deep-walk* [v s-map]
    (<span style="color: #a020f0;">cond</span>
      (<span style="color: #a020f0;">and</span> (= dot (first v))
           (sequential? (second v)))
      (deep-walk (second v) s-map)

      (seq v)
      (cons (deep-walk (first v) s-map)
            (deep-walk (rest v)  s-map))

      <span style="color: #008b8b;">:default</span> v)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Sequence goals</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Now we can define some user-level goals for sequences. First,
conso says that <i>out</i> is the sequence with the head <i>first</i> and the
tail <i>rest</i>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">conso</span> [first rest out]
  (<span style="color: #a020f0;">if</span> (lvar? rest)
    (=== [first dot rest] out)
    (=== (cons first rest) out)))
</pre>
</div>

<p>
<i>firsto</i> simply says that <i>first</i> is the head of <i>out</i>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">firsto</span> [first out]
  (fresh [rest]
    (conso first rest out)))
</pre>
</div>

<p>
And <i>resto</i>, likewise, says that <i>rest</i> is the tail of <i>out</i>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">resto</span> [rest out]
  (fresh [first]
    (conso first rest out)))
</pre>
</div>

<p>
<i>emptyo</i> is a way to say that <i>s</i> must be an empty sequence.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">emptyo</span> [s]
  (=== '() s))
</pre>
</div>

<p>
<i>appendo</i> says that <i>out</i> is the result of appending the sequence parameters
<i>seq1</i> and <i>seq1</i>.
</p>
<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">appendo</span> [seq1 seq2 out]
  (conde
    [(emptyo seq1) (=== seq2 out)]
    [(fresh [first rest rec]
       (conso first rest seq1)
       (conso first rec out)
       (appendo rest seq2 rec))]))
</pre>
</div>

<p>
You can do some interesting things with <i>appendo</i>. For example, this program
will find all the ways you can append two lists to create <code>[1 2 3 4 5]</code>:
</p>

<div class="org-src-container">

<pre class="src src-clojure">&gt; (run* [q]
    (fresh [x y]
      (appendo x y [1 2 3 4 5])
      (=== q [x y])))

((() (1 2 3 4 5))
 ((1)  (2 3 4 5))
 ((1 2)  (3 4 5))
 ((1 2 3)  (4 5))
 ((1 2 3 4)  (5))
 ((1 2 3 4 5) ()))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Back matter</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Bibliography</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>The microKanren paper: <a href="http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf">http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf</a>
</li>
<li>The microKanren scheme implementation: <a href="https://github.com/jasonhemann/microKanren">https://github.com/jasonhemann/microKanren</a>
</li>
<li>core.logic, Clojure's real miniKanren implementation: <a href="https://github.com/clojure/core.logic">https://github.com/clojure/core.logic</a>
</li>
<li>Will Byrd's dissertation on miniKanren: <a href="https://github.com/webyrd/dissertation-single-spaced/raw/master/thesis.pdf">https://github.com/webyrd/dissertation-single-spaced/raw/master/thesis.pdf</a>
</li>
<li>Chris Grand on the lazy stream monad, and mplus in particular: <a href="http://clj-me.cgrand.net/2012/01/30/the-reasoned-scheduler/">http://clj-me.cgrand.net/2012/01/30/the-reasoned-scheduler/</a>
</li>
<li>The Reasoned Schemer: <a href="http://mitpress.mit.edu/books/reasoned-schemer">http://mitpress.mit.edu/books/reasoned-schemer</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Differences from microKanren</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Polymorphic dispatch via protocols is used in place of <code>cond</code> with
type checks, where possible.
</p>

<p>
Clojure-native datatypes are used where appropriate
</p>
<ul class="org-ul">
<li>The substitution map is a clojure map instead of an alist
</li>
<li>There is an LVar defrecord, instead of using a vector of the lvar id.
</li>
<li>We have an explicit StreamNode data type, rather building on the
built-in list type.
</li>
<li>Clojure doesn't allow improper lists; we emulate it with the 'dot'
sigil.
</li>
</ul>

<p>
Many names have changed to be compatible with clojure, and to be more
approachable to those without knowledge of Scheme, monads or
miniKanren.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">uKanren</th>
<th scope="col" class="left">microLogic</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">c</td>
<td class="left">id</td>
</tr>

<tr>
<td class="left">mplus</td>
<td class="left">merge-streams</td>
</tr>

<tr>
<td class="left">bind</td>
<td class="left">mapcat-stream</td>
</tr>

<tr>
<td class="left">pull</td>
<td class="left">realize-stream-head</td>
</tr>

<tr>
<td class="left">mzero</td>
<td class="left">empty-stream</td>
</tr>

<tr>
<td class="left">unit</td>
<td class="left">stream</td>
</tr>

<tr>
<td class="left">Zzz</td>
<td class="left">delay-goal</td>
</tr>

<tr>
<td class="left">conj</td>
<td class="left">lconj</td>
</tr>

<tr>
<td class="left">disj</td>
<td class="left">ldisj</td>
</tr>

<tr>
<td class="left">==</td>
<td class="left"><code>===</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Differences from core.logic</h3>
<div class="outline-text-3" id="text-5-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">core.logic</th>
<th scope="col" class="left">microLogic</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">mplus</td>
<td class="left">merge-streams</td>
</tr>

<tr>
<td class="left">bind</td>
<td class="left">mapcat-stream</td>
</tr>

<tr>
<td class="left">pull</td>
<td class="left">realize-stream-head</td>
</tr>

<tr>
<td class="left">mzero</td>
<td class="left">empty-stream</td>
</tr>

<tr>
<td class="left">unit</td>
<td class="left">stream</td>
</tr>

<tr>
<td class="left">==</td>
<td class="left"><code>===</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Russell Mull</p>
<p class="date">Created: 2014-12-31 Wed 00:51</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
